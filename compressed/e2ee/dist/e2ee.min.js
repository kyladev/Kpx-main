var n=class i{#t={crypto:globalThis.crypto,TransformStream:globalThis.TransformStream};#e={counterLength:64,namedCurve:"P-256",keyLength:256};#r=null;#s={};#a=Symbol("unicast");constructor(r){Object.assign(this.#t,r?.deps),Object.assign(this.#e,r?.params)}async generateKeyPair({extractable:r=!1,additionalUsages:t=[]}={}){if(this.#r)throw new Error("Key pair already exists");this.#r=await this.#t.crypto.subtle.generateKey({name:"ECDH",namedCurve:this.#e.namedCurve},r,["deriveKey",...t])}async exportPublicKey(){if(!this.#r)throw new Error("Key pair not generated");return this.#o(this.#r.publicKey)}async setRemotePublicKey(r,t=this.#a){if(!this.#r)throw new Error("Key pair not generated");let e=await this.#y(r);this.#s[t]=await this.#t.crypto.subtle.deriveKey({name:"ECDH",public:e},this.#r.privateKey,{name:"AES-CTR",length:this.#e.keyLength},!1,["encrypt","decrypt"])}async encrypt(r,t=this.#a){if(!this.#s[t])throw new Error("Shared secret not set");return this.#n(this.#g(r),t)}encryptStream(r=this.#a){if(!this.#s[r])throw new Error("Shared secret not set");return new this.#t.TransformStream({transform:async(t,e)=>{e.enqueue(await this.#n(t,r))}})}async decrypt(r,t=this.#a){if(!this.#s[t])throw new Error("Shared secret not set");let e=await this.#i(r,t);return this.#d(e)}decryptStream(r=this.#a){if(!this.#s[r])throw new Error("Shared secret not set");return new this.#t.TransformStream({transform:async(t,e)=>{e.enqueue(await this.#i(t,r))}})}exportParams(){return this.#e}marshal(){return{keyPair:this.#r,params:this.exportParams()}}static unmarshal({marshalled:{keyPair:r,params:t},deps:e}){let s=new i({params:t,deps:e});return s.#p(r),s}async exportPrivateKey(){if(!this.#r)throw new Error("Key pair not generated");if(!this.#r.privateKey.extractable)throw new Error("Private key is not extractable");return this.#o(this.#r.privateKey)}async importKeyPair({privateKey:r,publicKey:t}){if(this.#r)throw new Error("Key pair already exists");let e=await this.#l(r),s=await this.#y(t);this.#r={privateKey:e,publicKey:s}}#p(r){this.#r=r}async#n(r,t){let e=this.#w(),s=new Uint8Array(await this.#t.crypto.subtle.encrypt({name:"AES-CTR",counter:e,length:this.#e.counterLength},this.#s[t],r));return this.#u({buffer:s,counter:e})}async#i(r,t){let{buffer:e,counter:s}=this.#m(r),a=await this.#t.crypto.subtle.decrypt({name:"AES-CTR",counter:s,length:this.#e.counterLength},this.#s[t],e);return new Uint8Array(a)}async#o(r){let t=await this.#t.crypto.subtle.exportKey("jwk",r);return JSON.stringify(t)}async#y(r){let t=JSON.parse(r);return await this.#t.crypto.subtle.importKey("jwk",t,{name:"ECDH",namedCurve:this.#e.namedCurve},!0,[])}async#l(r){let t=JSON.parse(r);return await this.#t.crypto.subtle.importKey("jwk",t,{name:"ECDH",namedCurve:this.#e.namedCurve},!0,t.key_ops)}#u({buffer:r,counter:t}){return JSON.stringify({buffer:this.#c(r),counter:this.#c(t)})}#m(r){let t=JSON.parse(r),e=this.#h(t.buffer),s=this.#h(t.counter);return{buffer:e,counter:s}}#d(r){return new TextDecoder().decode(r)}#g(r){return new TextEncoder().encode(r)}#h(r){return new Uint8Array([...r].map(t=>t.charCodeAt(0)))}#c(r){if(r.length<=8192)return String.fromCharCode(...r);let e="";for(let s=0;s<r.length;s+=8192){let a=r.subarray(s,s+8192);e+=String.fromCharCode(...a)}return e}#w(){return this.#t.crypto.getRandomValues(new Uint8Array(16))}};export{n as E2EE};
