// e2ee.ts
var E2EE = class _E2EE {
  #deps = { crypto: globalThis.crypto, TransformStream: globalThis.TransformStream };
  #params = {
    counterLength: 64,
    namedCurve: "P-256",
    keyLength: 256
  };
  #keyPair = null;
  #sharedSecrets = {};
  #unicast = Symbol("unicast");
  /**
   * @param options
   * @param options.deps Optionally inject your own platform dependencies.
   * @param options.deps.crypto An implementation of the WebCrypto API. Defaults to `globalThis.crypto`.
   * @param options.params Optionally override the default security parameters.
   * @param options.params.counterLength The length of the counter used in AES-CTR. Defaults to `64`.
   * @param options.params.namedCurve The named curve used in ECDH. Defaults to `P-256`.
   * @param options.params.keyLength The length of the key used in AES-CTR. Defaults to `256`.
   */
  constructor(options) {
    Object.assign(this.#deps, options?.deps);
    Object.assign(this.#params, options?.params);
  }
  /**
   * Generates an ECDH key pair for this party.
   * @param options
   * @param options.extractable Whether the key should be extractable. Defaults to `false`. SECURITY: Leave it to false, unless you know what you're doing.
   * @param options.additionalUsages Additional usages for the key. Defaults to `[]`.
   */
  async generateKeyPair({ extractable = false, additionalUsages = [] } = {}) {
    if (this.#keyPair) throw new Error("Key pair already exists");
    this.#keyPair = await this.#deps.crypto.subtle.generateKey(
      { name: "ECDH", namedCurve: this.#params.namedCurve },
      extractable,
      ["deriveKey", ...additionalUsages]
    );
  }
  /**
   * @returns The public key of this party, serialised as a JWK.
   */
  async exportPublicKey() {
    if (!this.#keyPair) throw new Error("Key pair not generated");
    return this.#marshalKey(this.#keyPair.publicKey);
  }
  /**
   * Set the public key generated by calling `exportPublicKey()` on another party. Provide an identifier
   * if you want to communicate with multiple parties from this one instance.
   * @param remotePublicKey The public key that was exported from another party, serialised as a JWK.
   * @param identifier Optional identifier for the other party, used for multi-cast communication. You can refer to this
   * identifier in future `encrypt()` and `decrypt()` calls to specify which party you want to communicate with.
   */
  async setRemotePublicKey(remotePublicKey, identifier = this.#unicast) {
    if (!this.#keyPair) throw new Error("Key pair not generated");
    const unmarshalled = await this.#unmarshalPublicKey(remotePublicKey);
    this.#sharedSecrets[identifier] = await this.#deps.crypto.subtle.deriveKey(
      { name: "ECDH", public: unmarshalled },
      this.#keyPair.privateKey,
      { name: "AES-CTR", length: this.#params.keyLength },
      false,
      ["encrypt", "decrypt"]
    );
  }
  /**
   * Encrypts the provided string with AES-CTR using the shared secret generated via the key exchange as the key.
   * @param plaintext Any JS string.
   * @param identifier Optional identifier for the other party, used for multi-cast communication.
   * @returns A string representing the ciphertext.
   */
  async encrypt(plaintext, identifier = this.#unicast) {
    if (!this.#sharedSecrets[identifier]) throw new Error("Shared secret not set");
    return this.#encryptRaw(this.#UTF8ToUint8Array(plaintext), identifier);
  }
  /**
   * A way to encrypt streaming Uint8Array data.
   * @param identifier Optional identifier for the other party, used for multi-cast communication
   * @returns A TransformStream that can be fitted in any pipeline to encrypt the data flowing through it.
   */
  encryptStream(identifier = this.#unicast) {
    if (!this.#sharedSecrets[identifier]) throw new Error("Shared secret not set");
    return new this.#deps.TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(await this.#encryptRaw(chunk, identifier));
      }
    });
  }
  /**
   * Decrypts the provided string with AES-CTR using the shared secret generated via the key exchange as the key.
   * @param ciphertext A string representing the ciphertext.
   * @param identifier Optional identifier for the other party, used for multi-cast communication.
   * @returns The decrypted string.
   */
  async decrypt(ciphertext, identifier = this.#unicast) {
    if (!this.#sharedSecrets[identifier]) throw new Error("Shared secret not set");
    const decrypted = await this.#decryptRaw(ciphertext, identifier);
    return this.#Uint8ArrayToUTF8(decrypted);
  }
  /**
   * Opposite of `encryptStream()`
   * @param identifier Optional identifier for the other party, used for multi-cast communication.
   * @returns A TransformStream that can be fitted in any pipeline to decrypt the data flowing through it.
   */
  decryptStream(identifier = this.#unicast) {
    if (!this.#sharedSecrets[identifier]) throw new Error("Shared secret not set");
    return new this.#deps.TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(await this.#decryptRaw(chunk, identifier));
      }
    });
  }
  /**
   *
   * @returns The parameters used to create this instance of E2EE.
   */
  exportParams() {
    return this.#params;
  }
  /**
   * A secure way to marshal this party's security parameters and key pair.
   * The key pair is returned as a `CryptoKeyPair` object, which means that the `CryptoKey` objects corresponding
   * to the two keys are facades. In particular, the private key cannot be viewed from JavaScript. As such, you cannot
   * serialise the key pair. Instead, store it in IndexedDB.
   * @returns An object with the security parameters of this party, and the key pair if it has been generated.
   */
  marshal() {
    return {
      keyPair: this.#keyPair,
      params: this.exportParams()
    };
  }
  /**
   * Restore a previously marshalled instance of `E2EE`.
   * @param options
   * @param options.marshalled The object returned by `marshal()`.
   * @param options.deps Optionally inject your own platform dependencies.
   * @returns A new instance of `E2EE` with the same security parameters and key pair as the marshalled instance.
   */
  static unmarshal({ marshalled: { keyPair, params }, deps }) {
    const e2ee = new _E2EE({ params, deps });
    e2ee.#restoreKeyPairObject(keyPair);
    return e2ee;
  }
  /**
   * In case you want to share the identity of this party across multiple instances of this class (maybe you want
   * to support multiple devices), use this method to securely share the private key between the devices.
   *
   * SECURITY: Make sure you handle the private key securely. It will be visible to JavaScript.
   * @returns  The private key of this party, serialised as a JWK.
   */
  async exportPrivateKey() {
    if (!this.#keyPair) throw new Error("Key pair not generated");
    if (!this.#keyPair.privateKey.extractable) throw new Error("Private key is not extractable");
    return this.#marshalKey(this.#keyPair.privateKey);
  }
  /**
   * Used in conjunction with `exportPrivateKey()` to share the private key between multiple instances of this class.
   *
   * SECURITY: Make sure you handle the private key securely. It will be visible to JavaScript.
   *
   * You can also use this to migrate your existing identities into this library.
   * @param options
   * @param options.privateKey The JWK of the private key you want to import.
   * @param options.publicKey The JWK of the public key you want to import.
   */
  async importKeyPair({ privateKey, publicKey }) {
    if (this.#keyPair) throw new Error("Key pair already exists");
    const unmarshalledPrivateKey = await this.#unmarshalPrivateKey(privateKey);
    const unmarshalledPublicKey = await this.#unmarshalPublicKey(publicKey);
    this.#keyPair = { privateKey: unmarshalledPrivateKey, publicKey: unmarshalledPublicKey };
  }
  #restoreKeyPairObject(keyPair) {
    this.#keyPair = keyPair;
  }
  async #encryptRaw(data, identifier) {
    const counter = this.#generateIv();
    const buffer = new Uint8Array(
      await this.#deps.crypto.subtle.encrypt(
        {
          name: "AES-CTR",
          counter,
          length: this.#params.counterLength
        },
        this.#sharedSecrets[identifier],
        data
      )
    );
    return this.#marshalCiphertext({ buffer, counter });
  }
  async #decryptRaw(data, identifier) {
    const { buffer, counter } = this.#unmarshalCiphertext(data);
    const decryptedBuffer = await this.#deps.crypto.subtle.decrypt(
      {
        name: "AES-CTR",
        counter,
        length: this.#params.counterLength
      },
      this.#sharedSecrets[identifier],
      buffer
    );
    return new Uint8Array(decryptedBuffer);
  }
  async #marshalKey(key) {
    const exported = await this.#deps.crypto.subtle.exportKey("jwk", key);
    const marshalled = JSON.stringify(exported);
    return marshalled;
  }
  async #unmarshalPublicKey(marshalled) {
    const unmarshalled = JSON.parse(marshalled);
    const key = await this.#deps.crypto.subtle.importKey(
      "jwk",
      unmarshalled,
      { name: "ECDH", namedCurve: this.#params.namedCurve },
      true,
      []
    );
    return key;
  }
  async #unmarshalPrivateKey(marshalled) {
    const unmarshalled = JSON.parse(marshalled);
    const key = await this.#deps.crypto.subtle.importKey(
      "jwk",
      unmarshalled,
      { name: "ECDH", namedCurve: this.#params.namedCurve },
      true,
      unmarshalled.key_ops
    );
    return key;
  }
  #marshalCiphertext({ buffer, counter }) {
    const marshalled = JSON.stringify({
      buffer: this.#Uint8ArrayToAscii(buffer),
      counter: this.#Uint8ArrayToAscii(counter)
    });
    return marshalled;
  }
  #unmarshalCiphertext(marshalled) {
    const unmarshalled = JSON.parse(marshalled);
    const buffer = this.#asciiToUint8Array(unmarshalled.buffer);
    const counter = this.#asciiToUint8Array(unmarshalled.counter);
    return { buffer, counter };
  }
  #Uint8ArrayToUTF8(buffer) {
    return new TextDecoder().decode(buffer);
  }
  #UTF8ToUint8Array(text) {
    return new TextEncoder().encode(text);
  }
  #asciiToUint8Array(text) {
    return new Uint8Array([...text].map((c) => c.charCodeAt(0)));
  }
  #Uint8ArrayToAscii(buffer) {
    const CHUNK_SIZE = 8192;
    if (buffer.length <= CHUNK_SIZE) {
      return String.fromCharCode(...buffer);
    }
    let accum = "";
    for (let i = 0; i < buffer.length; i += CHUNK_SIZE) {
      const chunk = buffer.subarray(i, i + CHUNK_SIZE);
      accum += String.fromCharCode(...chunk);
    }
    return accum;
  }
  #generateIv() {
    return this.#deps.crypto.getRandomValues(new Uint8Array(16));
  }
};
export {
  E2EE
};
